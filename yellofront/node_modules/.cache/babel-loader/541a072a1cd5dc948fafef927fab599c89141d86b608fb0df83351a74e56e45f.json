{"ast":null,"code":"module.exports = function () {\n  'use strict';\n\n  const R = require('./ramda.js');\n  const isString = R.is(String);\n  const isArray = R.is(Array);\n  const isObject = R.is(Object);\n  const isArrayOrObject = R.anyPass([isArray, isObject]);\n  const mapToObject = R.curry((mapFn, array) => R.fromPairs(R.map(val => R.pair(val, mapFn(val)), array)));\n  const convertBooleans = R.map(val => {\n    if (val === true) return 1;\n    if (val === false) return 0;\n    return val;\n  });\n  const unnestParameters = params => {\n    if (!isArrayOrObject(params)) {\n      return params;\n    }\n    const recursedPairs = R.compose(R.toPairs, R.map(unnestParameters))(params);\n    const flattenedPairs = recursedPairs.map(_ref => {\n      let [key, value] = _ref;\n      return isObject(value) ? R.compose(R.fromPairs, R.map(_ref2 => {\n        let [subKey, subValue] = _ref2;\n        return [`${key}__${subKey}`, subValue];\n      }), R.toPairs)(value) : {\n        [key]: value\n      };\n    });\n    return R.mergeAll(flattenedPairs);\n  };\n  const splitwisifyParameters = R.compose(convertBooleans, unnestParameters);\n  const getSplitwiseErrors = error => {\n    if (!error) {\n      return [];\n    }\n    if (isString(error)) {\n      try {\n        return getSplitwiseErrors(JSON.parse(error));\n      } catch (e) {\n        return [error];\n      }\n    }\n    return R.flatten([error.message, error.error, error.data, R.values(error.errors)]).filter(e => !!e).map(getSplitwiseErrors);\n  };\n  return {\n    isString,\n    mapToObject,\n    splitwisifyParameters,\n    getSplitwiseErrors\n  };\n}();","map":{"version":3,"names":["module","exports","R","require","isString","is","String","isArray","Array","isObject","Object","isArrayOrObject","anyPass","mapToObject","curry","mapFn","array","fromPairs","map","val","pair","convertBooleans","unnestParameters","params","recursedPairs","compose","toPairs","flattenedPairs","key","value","subKey","subValue","mergeAll","splitwisifyParameters","getSplitwiseErrors","error","JSON","parse","e","flatten","message","data","values","errors","filter"],"sources":["C:/Users/Suweb Reza/OneDrive/Desktop/yello code hackathon/yellocodefrontend/node_modules/splitwise/src/utils.js"],"sourcesContent":["module.exports = (function () {\n  'use strict'\n\n  const R = require('./ramda.js')\n\n  const isString = R.is(String)\n  const isArray = R.is(Array)\n  const isObject = R.is(Object)\n  const isArrayOrObject = R.anyPass([isArray, isObject])\n\n  const mapToObject = R.curry((mapFn, array) => R.fromPairs(\n    R.map(val => R.pair(val, mapFn(val)), array)\n  ))\n\n  const convertBooleans = R.map(val => {\n    if (val === true) return 1\n    if (val === false) return 0\n    return val\n  })\n\n  const unnestParameters = params => {\n    if (!isArrayOrObject(params)) {\n      return params\n    }\n\n    const recursedPairs = R.compose(\n      R.toPairs,\n      R.map(unnestParameters)\n    )(params)\n\n    const flattenedPairs = recursedPairs.map(\n      ([key, value]) =>\n        isObject(value)\n          ? R.compose(\n            R.fromPairs,\n            R.map(([subKey, subValue]) => [`${key}__${subKey}`, subValue]),\n            R.toPairs\n          )(value)\n          : { [key]: value }\n    )\n\n    return R.mergeAll(flattenedPairs)\n  }\n\n  const splitwisifyParameters = R.compose(\n    convertBooleans,\n    unnestParameters\n  )\n\n  const getSplitwiseErrors = error => {\n    if (!error) {\n      return []\n    }\n    if (isString(error)) {\n      try {\n        return getSplitwiseErrors(JSON.parse(error))\n      } catch (e) {\n        return [error]\n      }\n    }\n\n    return R.flatten([\n      error.message,\n      error.error,\n      error.data,\n      R.values(error.errors)\n    ]).filter(e => !!e).map(getSplitwiseErrors)\n  }\n\n  return {\n    isString,\n    mapToObject,\n    splitwisifyParameters,\n    getSplitwiseErrors\n  }\n}())\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}